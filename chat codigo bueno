import os
import json
import time
import random
import numpy as np
from coppeliasim_zmqremoteapi_client import RemoteAPIClient

# =========================================================
# ----------- CONFIG GENERAL DEL ROBOT / ESCENA -----------
# =========================================================

WHEEL_D = 0.05       # diámetro llanta [m]
MAX_SPEED = 1.2      # velocidad lineal máx [m/s]
BASE_SPEED = 0.4     # velocidad base hacia adelante (0 a 1 aprox)
MAX_CORRECTION = 0.6 # cuánto puedo girar máx (0 a 1)
STEERING_SIGN = 1.0  # <-- SI SE PONE A GIRAR EN DONAS, CAMBIA A -1.0

LOST_LINE_THRESHOLD = 0  # si no ve negro en ningún sensor: asumimos línea perdida
CONTROL_DT = 0.01        # segundos entre steps de control
EPISODE_TIME = 3.0       # duración de cada episodio en segundos reales
LOG_DIR = "logs"         # carpeta donde guardamos las pruebas

# Crea carpeta de logs si no existe
os.makedirs(LOG_DIR, exist_ok=True)

# =========================================================
# --------- CONEXIÓN A COPPELIASIM / HANDLES --------------
# =========================================================
client = RemoteAPIClient('localhost', 23000)
sim = client.getObject('sim')

left_mtr = sim.getObject('/LineTracer/DynamicLeftJoint')
right_mtr = sim.getObject('/LineTracer/DynamicRightJoint')
cam_handles = [sim.getObject(f"/LineTracer/lineSensor[{i}]") for i in range(8)]


# =========================================================
# -------------------- FUNCIONES BASE ---------------------
# =========================================================

def get_sensor_values(threshold=0.2):
    """
    Lee los 8 sensores de visión y regresa una lista de 0/1
    1 = línea negra detectada, 0 = piso claro
    """
    states = []
    for h in cam_handles:
        img, res = sim.getVisionSensorImg(h)
        w, hres = int(res[0]), int(res[1])

        buf = np.frombuffer(img, dtype=np.uint8)
        frame = buf.reshape(hres, w, 3).astype(np.float32) / 255.0
        gray = frame.mean(axis=2)

        detected = 1 if gray.mean() < threshold else 0
        states.append(detected)
    return states


def set_motor_speeds(norm_left, norm_right):
    """
    norm_left, norm_right en [-1, 1].
    Se convierten a velocidad angular de cada junta.
    """
    # saturamos
    norm_left = max(-1.0, min(1.0, norm_left))
    norm_right = max(-1.0, min(1.0, norm_right))

    # normalizado -> lineal
    left_linear_velocity = norm_left * MAX_SPEED
    right_linear_velocity = norm_right * MAX_SPEED

    # lineal -> angular
    left_ang_vel = left_linear_velocity / (WHEEL_D / 2)
    right_ang_vel = right_linear_velocity / (WHEEL_D / 2)

    client.setStepping(True)
    sim.setJointTargetVelocity(left_mtr, left_ang_vel)
    sim.setJointTargetVelocity(right_mtr, right_ang_vel)
    client.setStepping(False)


def compute_line_error(sensors, last_error):
    """
    Convierte sensores [s0..s7] a un error continuo.
    Pesos más negativos = más a la izquierda.
    Pesos más positivos = más a la derecha.
    """
    weights = np.array([-3, -2, -1, -0.5, 0.5, 1, 2, 3], dtype=float)
    s = np.array(sensors, dtype=float)

    active_sum = s.sum()

    if active_sum <= LOST_LINE_THRESHOLD:
        # No vemos la línea -> mantenemos la misma dirección que traíamos
        return last_error

    weighted_pos = (weights * s).sum() / active_sum
    return weighted_pos


class PIDController:
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0.0
        self.prev_error = 0.0
        self.prev_time = None

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0
        self.prev_time = None

    def update(self, error):
        now = time.time()
        if self.prev_time is None:
            dt = 0.0
        else:
            dt = now - self.prev_time
            if dt <= 0:
                dt = 1e-6

        # PID
        P = self.Kp * error
        self.integral += error * dt
        I = self.Ki * self.integral
        d_error = (error - self.prev_error) / dt if dt > 0 else 0.0
        D = self.Kd * d_error

        # guardar estado
        self.prev_error = error
        self.prev_time = now

        return P + I + D


def apply_pid_to_motors(pid_output):
    """
    Toma la salida del PID y calcula las velocidades de las ruedas.
    STEERING_SIGN controla la dirección del giro.
    """
    correction = STEERING_SIGN * pid_output

    # Limitar qué tan agresivo puede girar
    correction = max(-MAX_CORRECTION, min(MAX_CORRECTION, correction))

    left_cmd = BASE_SPEED - correction
    right_cmd = BASE_SPEED + correction

    # saturar seguridad [-1, 1]
    left_cmd = max(-1.0, min(1.0, left_cmd))
    right_cmd = max(-1.0, min(1.0, right_cmd))

    set_motor_speeds(left_cmd, right_cmd)


# =========================================================
# -------- EPISODIO DE SIMULACIÓN / FUNCIÓN REWARD --------
# =========================================================

def run_episode(params, episode_idx):
    """
    Corre la simulación con parámetros PID dados.
    Devuelve una recompensa 'reward' y estadísticas.

    params = {
        "Kp": float,
        "Ki": float,
        "Kd": float
    }

    Recompensa básica:
    - Queremos que el robot se mantenga centrado (error pequeño)
    - Queremos que avance (ruedas no paradas)
    """

    # Creamos controlador PID con estos params
    pid = PIDController(params["Kp"], params["Ki"], params["Kd"])

    # Reinicia escena:
    # En CoppeliaSim, stopSimulation -> startSimulation normalmente
    # regresa al estado inicial de la escena.
    sim.stopSimulation()
    # mini delay para que CoppeliaSim procese el stop
    time.sleep(0.2)
    sim.startSimulation()

    start_time = time.time()
    last_error = 0.0

    abs_error_sum = 0.0
    step_count = 0
    straightness_sum = 0.0  # proxy de avance estable

    while sim.getSimulationState() != sim.simulation_stopped:
        now = time.time()
        if (now - start_time) >= EPISODE_TIME:
            # terminamos este episodio
            break

        sensors = get_sensor_values()
        err = compute_line_error(sensors, last_error)
        last_error = err

        pid_out = pid.update(err)
        apply_pid_to_motors(pid_out)

        # Métrica de qué tan desviado estás
        abs_error_sum += abs(err)

        # Métrica de "avance recto": si las dos ruedas están parecidas al BASE_SPEED
        # interpretamos que el robot está avanzando y no girando loco.
        # Nota: esto es aproximado, porque no leemos la velocidad real del joint,
        # pero sirve como heurística.
        straightness = 1.0 - min(1.0, abs(pid_out))  # grande si pid_out ~ 0
        straightness_sum += straightness

        step_count += 1
        time.sleep(CONTROL_DT)

    # Frenar robot
    set_motor_speeds(0.0, 0.0)
    sim.stopSimulation()
    time.sleep(0.1)

    if step_count == 0:
        avg_err = 999.0
        avg_straight = 0.0
    else:
        avg_err = abs_error_sum / step_count
        avg_straight = straightness_sum / step_count

    # Definimos recompensa:
    # - Penalizar error promedio
    # - Premiar ir "recto"
    # Puedes tunear estos pesos.
    reward = (2.0 * avg_straight) - (1.0 * avg_err)

    # Guardar log del episodio
    data = {
        "episode": episode_idx,
        "params": params,
        "avg_error": avg_err,
        "avg_straight": avg_straight,
        "reward": reward,
        "timestamp": time.time()
    }

    log_path = os.path.join(LOG_DIR, f"prueba_{episode_idx}.json")
    with open(log_path, "w") as f:
        json.dump(data, f, indent=2)

    print(f"[EP {episode_idx}] reward={reward:.3f}  err={avg_err:.3f}  straight={avg_straight:.3f}")
    print(f"guardado en {log_path}")

    return reward, data


# =========================================================
# ---------- LOOP DE "APRENDIZAJE" / BUSCADOR PID ---------
# =========================================================

def mutate_params(best_params, scale=0.2):
    """
    Hace una 'mutación' aleatoria de los mejores params.
    scale controla qué tan agresivo muta.
    Nos aseguramos que no sean negativos raros.
    """
    def mutate(val):
        return max(0.0, val + random.gauss(0, scale * abs(val + 1e-6)))

    new_params = {
        "Kp": mutate(best_params["Kp"]),
        "Ki": mutate(best_params["Ki"]),
        "Kd": mutate(best_params["Kd"]),
    }
    return new_params


def save_best(best_data):
    best_path = os.path.join(LOG_DIR, "best_params.json")
    with open(best_path, "w") as f:
        json.dump(best_data, f, indent=2)
    print(f"[MEJOR ACTUALIZADO] {best_path}")


if __name__ == "__main__":
    # PID inicial (tú puedes cambiar esto)
    best_params = {
        "Kp": 0.8,
        "Ki": 0.0,
        "Kd": 0.15
    }

    # Evaluar episodio 0 con params iniciales
    best_reward, best_data = run_episode(best_params, episode_idx=0)
    save_best(best_data)

    # Número total de episodios que quieres probar en este run
    # (puedes subirlo cuando ya esté estable)
    NUM_EPISODES = 10

    for ep in range(1, NUM_EPISODES + 1):
        # Proponemos nuevos PID basados en el mejor hasta ahora
        candidate_params = mutate_params(best_params, scale=0.3)

        reward, data = run_episode(candidate_params, episode_idx=ep)

        # Si mejora, lo adoptamos como el nuevo best
        if reward > best_reward:
            best_reward = reward
            best_params = candidate_params
            best_data = data
            save_best(best_data)

    # Al final del script, motores en 0 por seguridad
    set_motor_speeds(0.0, 0.0)
