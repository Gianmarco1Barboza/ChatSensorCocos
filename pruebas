import os
import json
import time
import random
import numpy as np
from coppeliasim_zmqremoteapi_client import RemoteAPIClient

# =========================================================
# -------- CONFIG QUE *TÚ* PUEDES / DEBES TOCAR ----------
# =========================================================

WHEEL_D = 0.05          # m (diámetro de la llanta)
MAX_SPEED = 1.2         # m/s máx que quieres permitir físicamente
MAX_CORRECTION = 0.6    # límite de giro diferencial (más alto = gira más agresivo)

# IMPORTANTE:
# Muchos robots diferenciales en simulador tienen una rueda "invertida".
# Si al mandar las dos ruedas con el mismo valor el robot gira en su lugar,
# entonces una rueda está al revés.
#
# Ajusta estos signos hasta que cuando mandemos L=+0.4, R=+0.4 el robot AVANCE recto.
MOTOR_SIGN_LEFT  = 1.0
MOTOR_SIGN_RIGHT = -1.0  # <-- si aún gira en círculo, prueba cambiando este a 1.0 y el de la izq a -1.0

# Tus sensores están montados en el lado IZQUIERDO del robot,
# no al frente centrados. Para interpretar eso bien:
WEIGHTS = np.array([3, 2, 1, 0.5, -0.5, -1, -2, -3], dtype=float)

# Medimos que cuando el robot está en la posición correcta respecto a la línea,
# el weighted_pos ≈ -5. Eso lo tomamos como "perfecto".
TARGET_OFFSET = -5.0

# Giro lógico: si el robot corrige al lado contrario, cámbialo a -1.0
STEERING_SIGN = 1.0

EPISODE_TIME = 4.0      # segundos por episodio de entrenamiento
CONTROL_DT = 0.02       # paso de control
LOST_LINE_THRESHOLD = 0 # si no ve línea (todos 0), asumimos línea perdida
LOG_DIR = "logs"
os.makedirs(LOG_DIR, exist_ok=True)

# =========================================================
# --------- CONEXIÓN A COPPELIASIM Y HANDLES --------------
# =========================================================

client = RemoteAPIClient('localhost', 23000)
sim = client.getObject('sim')

left_mtr = sim.getObject('/LineTracer/DynamicLeftJoint')
right_mtr = sim.getObject('/LineTracer/DynamicRightJoint')
cam_handles = [sim.getObject(f"/LineTracer/lineSensor[{i}]") for i in range(8)]

# =========================================================
# ---------------- FUNCIONES DEL ROBOT --------------------
# =========================================================

def get_sensor_values(threshold=0.2):
    """
    Devuelve lista de 8 valores 0/1 (1 = línea negra detectada).
    """
    states = []
    for h in cam_handles:
        img, res = sim.getVisionSensorImg(h)
        w, hres = int(res[0]), int(res[1])

        buf = np.frombuffer(img, dtype=np.uint8)
        frame = buf.reshape(hres, w, 3).astype(np.float32) / 255.0
        gray = frame.mean(axis=2)

        detected = 1 if gray.mean() < threshold else 0
        states.append(detected)
    return states


def set_motor_speeds(norm_left, norm_right):
    """
    norm_left / norm_right están en [-1,1] (comandos lógicos).
    Aquí los convertimos a velocidades físicas tomando en cuenta:
    - saturación
    - MAX_SPEED
    - radio de la rueda
    - signo del motor (MOTOR_SIGN_LEFT / MOTOR_SIGN_RIGHT)
    """

    # saturar comandos lógicos
    nl = max(-1.0, min(1.0, norm_left))
    nr = max(-1.0, min(1.0, norm_right))

    # aplicar signo de cada motor
    nl *= MOTOR_SIGN_LEFT
    nr *= MOTOR_SIGN_RIGHT

    # comando lógico -> velocidad lineal (m/s)
    left_linear_velocity = nl * MAX_SPEED
    right_linear_velocity = nr * MAX_SPEED

    # velocidad lineal -> velocidad angular (rad/s)
    left_ang_vel = left_linear_velocity / (WHEEL_D / 2)
    right_ang_vel = right_linear_velocity / (WHEEL_D / 2)

    client.setStepping(True)
    sim.setJointTargetVelocity(left_mtr, left_ang_vel)
    sim.setJointTargetVelocity(right_mtr, right_ang_vel)
    client.setStepping(False)

    # Regresamos LOS COMANDOS LÓGICOS antes del signo? o después?
    # Para métrica de "forward" nos interesa el movimiento físico real.
    # forward_cmd = promedio de nl y nr DESPUÉS de signo.
    return nl, nr


def compute_line_error(sensors, last_error):
    """
    1. Calcula weighted_pos con WEIGHTS (sensores en el costado izquierdo).
    2. Resta TARGET_OFFSET (= -5.0 medido por ti).
       Si estamos donde queremos, error ~ 0.
    """
    s = np.array(sensors, dtype=float)
    active_sum = s.sum()

    if active_sum <= LOST_LINE_THRESHOLD:
        # No veo línea: mantengo el último error para seguir girando hacia donde iba.
        return last_error

    weighted_pos = (WEIGHTS * s).sum() / active_sum
    error = weighted_pos - TARGET_OFFSET
    return error


class PIDController:
    """
    PID clásico: salida = Kp*e + Ki*∫e dt + Kd*de/dt
    """
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0.0
        self.prev_error = 0.0
        self.prev_time = None

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0
        self.prev_time = None

    def update(self, error):
        now = time.time()

        if self.prev_time is None:
            dt = 0.0
        else:
            dt = now - self.prev_time
            if dt <= 0:
                dt = 1e-6

        P = self.Kp * error
        self.integral += error * dt
        I = self.Ki * self.integral
        d_error = (error - self.prev_error) / dt if dt > 0 else 0.0
        D = self.Kd * d_error

        self.prev_error = error
        self.prev_time = now

        return P + I + D


def apply_controller(pid_output, base_speed):
    """
    Convierte la salida PID a comandos de rueda.
    STEERING_SIGN decide el sentido de giro (corrige izquierda/derecha).
    """
    correction = STEERING_SIGN * pid_output

    # limitar qué tan agresivo puede girar
    correction = max(-MAX_CORRECTION, min(MAX_CORRECTION, correction))

    left_cmd = base_speed - correction
    right_cmd = base_speed + correction

    # saturar lógicamente [-1,1] ANTES del signo físico del motor
    left_cmd = max(-1.0, min(1.0, left_cmd))
    right_cmd = max(-1.0, min(1.0, right_cmd))

    return set_motor_speeds(left_cmd, right_cmd)


# =========================================================
# ----------- EPISODIO DE ENTRENAMIENTO -------------------
# =========================================================

def run_episode(params, episode_idx):
    """
    Corre 1 episodio con:
      {
        "Kp": float,
        "Ki": float,
        "Kd": float,
        "BASE_SPEED": float
      }
    Calcula recompensa y guarda logs/prueba_#.json
    """
    pid = PIDController(params["Kp"], params["Ki"], params["Kd"])
    pid.reset()

    base_speed = params["BASE_SPEED"]

    # Reiniciar simulación al estado inicial
    sim.stopSimulation()
    time.sleep(0.2)
    sim.startSimulation()

    start_time = time.time()
    last_error = 0.0

    abs_error_sum = 0.0
    forward_sum = 0.0
    step_count = 0

    while sim.getSimulationState() != sim.simulation_stopped:
        now = time.time()
        if (now - start_time) >= EPISODE_TIME:
            break

        sensors = get_sensor_values()
        err = compute_line_error(sensors, last_error)
        last_error = err

        pid_out = pid.update(err)

        nl, nr = apply_controller(pid_out, base_speed)

        # acumulamos métrica de qué tan lejos de la línea estás
        abs_error_sum += abs(err)

        # métrica de avance real:
        # si las dos ruedas (después de signo) están positivas, sumamos
        forward_cmd = (nl + nr) / 2.0
        if forward_cmd < 0:
            forward_cmd = 0.0
        forward_sum += forward_cmd

        step_count += 1
        time.sleep(CONTROL_DT)

    # parar robot y simulación
    set_motor_speeds(0.0, 0.0)
    sim.stopSimulation()
    time.sleep(0.1)

    if step_count == 0:
        avg_err = 999.0
        avg_forward = 0.0
    else:
        avg_err = abs_error_sum / step_count
        avg_forward = forward_sum / step_count

    # Recompensa = queremos avanzar + mantenernos cerca donde debemos estar
    reward = (2.0 * avg_forward) - (1.0 * avg_err)

    data = {
        "episode": episode_idx,
        "params": params,
        "avg_error": avg_err,
        "avg_forward": avg_forward,
        "reward": reward,
        "timestamp": time.time()
    }

    log_path = os.path.join(LOG_DIR, f"prueba_{episode_idx}.json")
    with open(log_path, "w") as f:
        json.dump(data, f, indent=2)

    print(f"[EP {episode_idx}] reward={reward:.3f}  err={avg_err:.3f}  fwd={avg_forward:.3f}")
    print(f"Guardado en {log_path}")

    return reward, data


# =========================================================
# ----------- BÚSQUEDA ESTILO RL / EVOLUTIVA --------------
# =========================================================

def mutate_params(best_params, scale=0.3):
    """
    Crea nuevos parámetros parecidos a los mejores actuales,
    con ruido gaussiano.
    """
    def mutate_positive(val, allow_zero=True):
        new_val = val + random.gauss(0, scale * (abs(val) + 1e-6))
        if allow_zero:
            new_val = max(0.0, new_val)
        else:
            new_val = max(0.05, new_val)  # evita BASE_SPEED = 0
        return new_val

    new_params = {
        "Kp": mutate_positive(best_params["Kp"]),
        "Ki": mutate_positive(best_params["Ki"]),
        "Kd": mutate_positive(best_params["Kd"]),
        "BASE_SPEED": mutate_positive(best_params["BASE_SPEED"], allow_zero=False),
    }

    # BASE_SPEED debe quedar entre 0 y 1 porque la tratamos como normalizada
    new_params["BASE_SPEED"] = min(1.0, new_params["BASE_SPEED"])
    return new_params


def save_best(best_data):
    best_path = os.path.join(LOG_DIR, "best_params.json")
    with open(best_path, "w") as f:
        json.dump(best_data, f, indent=2)
    print(f"[MEJOR ACTUALIZADO] {best_path}")


if __name__ == "__main__":
    # Semilla inicial
    best_params = {
        "Kp": 0.6,
        "Ki": 0.0,
        "Kd": 0.1,
        "BASE_SPEED": 0.4   # si va demasiado loco, bájalo a 0.2
    }

    best_reward, best_data = run_episode(best_params, episode_idx=0)
    save_best(best_data)

    NUM_EPISODES = 10

    for ep in range(1, NUM_EPISODES + 1):
        cand_params = mutate_params(best_params, scale=0.3)
        reward, data = run_episode(cand_params, episode_idx=ep)

        if reward > best_reward:
            best_reward = reward
            best_params = cand_params
            best_data = data
            save_best(best_data)

    # Apagar motores al final
    set_motor_speeds(0.0, 0.0)
