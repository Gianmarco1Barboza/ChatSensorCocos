import numpy as np
from coppeliasim_zmqremoteapi_client import RemoteAPIClient
import time

# --- Functions you can use (don't change) --- #
def get_sensor_values(threshold=0.2):
    """
    Read the 8 vision sensors and return a list of 0/1 values
    (1 = line detected, 0 = no line)
    """
    states = []
    for h in cam_handles:
        img, res = sim.getVisionSensorImg(h)
        w, hres = int(res[0]), int(res[1])
        buf = np.frombuffer(img, dtype=np.uint8)
        frame = buf.reshape(hres, w, 3).astype(np.float32) / 255.0
        gray = frame.mean(axis=2)
        detected = 1 if gray.mean() < threshold else 0
        states.append(detected)
    return states

def set_motor_speeds(norm_left, norm_right):
    """Set both wheel speeds using normalized values (-1 to 1)"""
    norm_left = max(-1.0, min(1.0, norm_left))
    norm_right = max(-1.0, min(1.0, norm_right))
    
    left_linear_velocity = norm_left * MAX_SPEED
    right_linear_velocity = norm_right * MAX_SPEED
    
    left_angular_velocity = left_linear_velocity / (WHEEL_D / 2)
    right_angular_velocity = right_linear_velocity / (WHEEL_D / 2)
    
    client.setStepping(True)
    sim.setJointTargetVelocity(left_mtr, left_angular_velocity)
    sim.setJointTargetVelocity(right_mtr, right_angular_velocity)
    client.setStepping(False)

def calculate_line_position(sensors):
    """
    Calculate the position of the line relative to the robot center.
    Returns a value between -1 (far left) and 1 (far right), 0 = center
    """
    weights = [-3.5, -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, 3.5]
    
    weighted_sum = sum(sensor * weight for sensor, weight in zip(sensors, weights))
    sensor_count = sum(sensors)
    
    if sensor_count == 0:
        return None
    
    position = weighted_sum / sensor_count
    return position / 3.5

def detect_finish_line(sensors):
    """Detect if we've reached the finish line (many sensors detecting black)"""
    sensor_count = sum(sensors)
    return sensor_count >= 6  # If 6 or more sensors detect black, it's likely the finish

def smooth_speed_transition(current_speed, target_speed, max_change=0.05):
    """Gradually change speed to avoid abrupt changes"""
    if abs(target_speed - current_speed) <= max_change:
        return target_speed
    elif target_speed > current_speed:
        return current_speed + max_change
    else:
        return current_speed - max_change

# --- Initialization code --- #
WHEEL_D = 0.05
MAX_SPEED = 1.2
client = RemoteAPIClient('localhost', 23000)
sim = client.getObject('sim')
left_mtr = sim.getObject('/LineTracer/DynamicLeftJoint')
right_mtr = sim.getObject('/LineTracer/DynamicRightJoint')
cam_handles = [sim.getObject(f"/LineTracer/lineSensor[{i}]") for i in range(8)]

# --- Improved Control parameters --- #
BASE_SPEED = 0.4           # Reduced base speed for stability
MIN_SPEED = 0.2            # Minimum speed for curves
MAX_CURVE_SPEED = 0.3      # Maximum speed in curves
STEERING_GAIN = 0.4        # Reduced steering gain for smoother control
SEARCH_SPEED = 0.25        # Speed when searching for line

# Enhanced PID Controller
class SmoothPIDController:
    def __init__(self, kp=0.5, ki=0.0, kd=0.15):
        self.kp = kp
        self.ki = ki
        self.kd = kd
        self.previous_error = 0
        self.integral = 0
        self.last_time = time.time()
        self.error_history = []
        self.max_output = 1.0
        
    def update(self, error):
        current_time = time.time()
        dt = current_time - self.last_time
        
        if dt <= 0:
            dt = 0.01
        
        # Smooth the error using moving average
        self.error_history.append(error)
        if len(self.error_history) > 3:  # Keep last 3 values
            self.error_history.pop(0)
        
        smoothed_error = sum(self.error_history) / len(self.error_history)
        
        # PID calculation with smoothed error
        proportional = self.kp * smoothed_error
        
        # Limit integral windup
        self.integral += smoothed_error * dt
        self.integral = max(-1.0, min(1.0, self.integral))
        integral = self.ki * self.integral
        
        derivative = self.kd * (smoothed_error - self.previous_error) / dt
        
        output = proportional + integral + derivative
        
        # Limit output
        output = max(-self.max_output, min(self.max_output, output))
        
        self.previous_error = smoothed_error
        self.last_time = current_time
        
        return output

# Line Recovery System
class LineRecovery:
    def __init__(self):
        self.recovery_mode = False
        self.recovery_direction = 0  # -1 for left, 1 for right
        self.recovery_start_time = 0
        self.max_recovery_time = 2.0  # Maximum time to try recovery
        self.backup_distance = 0
        
    def start_recovery(self, last_position):
        """Start recovery mode based on last known line position"""
        self.recovery_mode = True
        self.recovery_direction = 1 if last_position > 0 else -1
        self.recovery_start_time = time.time()
        self.backup_distance = 0
        print(f"Starting recovery mode, direction: {'right' if self.recovery_direction > 0 else 'left'}")
        
    def get_recovery_speeds(self):
        """Get motor speeds for recovery maneuver"""
        elapsed_time = time.time() - self.recovery_start_time
        
        if elapsed_time < 0.5:
            # First phase: backup slightly
            return -SEARCH_SPEED * 0.5, -SEARCH_SPEED * 0.5
        else:
            # Second phase: turn to search for line
            if self.recovery_direction > 0:  # Turn right
                return SEARCH_SPEED * 0.8, -SEARCH_SPEED * 0.6
            else:  # Turn left
                return -SEARCH_SPEED * 0.6, SEARCH_SPEED * 0.8
                
    def should_stop_recovery(self):
        """Check if recovery should stop (timeout)"""
        return time.time() - self.recovery_start_time > self.max_recovery_time
        
    def reset(self):
        """Reset recovery system"""
        self.recovery_mode = False
        print("Recovery mode ended")

# Initialize systems
pid = SmoothPIDController(kp=0.6, ki=0.0, kd=0.2)
recovery = LineRecovery()

# State variables
last_line_position = 0
line_lost_counter = 0
MAX_LINE_LOST = 5  # Reduced for faster recovery
current_left_speed = 0
current_right_speed = 0
consecutive_good_readings = 0

# Main control loop
if __name__ == "__main__":
    try:
        sim.startSimulation()
        print("Simulation started. Robot should start following the line...")
        
        while sim.getSimulationState() != sim.simulation_stopped:
            sensors = get_sensor_values()
            print(f"Sensors: {sensors}")
            
            # Check for finish line
            if detect_finish_line(sensors):
                print("ðŸ FINISH LINE DETECTED! Stopping robot.")
                set_motor_speeds(0, 0)
                time.sleep(1)
                break
            
            # Calculate line position
            line_position = calculate_line_position(sensors)
            
            if line_position is not None:
                # Line detected - reset recovery and counters
                if recovery.recovery_mode:
                    recovery.reset()
                line_lost_counter = 0
                last_line_position = line_position
                consecutive_good_readings += 1
                
                # Calculate steering with PID
                steering_correction = pid.update(line_position)
                
                # Adaptive speed based on line position and stability
                error_magnitude = abs(line_position)
                if error_magnitude > 0.7:  # Sharp curve
                    target_base_speed = MIN_SPEED
                elif error_magnitude > 0.4:  # Medium curve
                    target_base_speed = MAX_CURVE_SPEED
                elif consecutive_good_readings > 10:  # Stable straight line
                    target_base_speed = BASE_SPEED
                else:  # Recently recovered
                    target_base_speed = MAX_CURVE_SPEED
                
                # Calculate target speeds
                target_left = target_base_speed - STEERING_GAIN * steering_correction
                target_right = target_base_speed + STEERING_GAIN * steering_correction
                
                # Smooth speed transitions
                left_speed = smooth_speed_transition(current_left_speed, target_left)
                right_speed = smooth_speed_transition(current_right_speed, target_right)
                
                print(f"Line pos: {line_position:.2f}, Correction: {steering_correction:.2f}, Speed: L={left_speed:.2f} R={right_speed:.2f}")
                
            else:
                # No line detected
                consecutive_good_readings = 0
                line_lost_counter += 1
                print(f"Line lost! Counter: {line_lost_counter}")
                
                if line_lost_counter >= MAX_LINE_LOST and not recovery.recovery_mode:
                    # Start recovery mode
                    recovery.start_recovery(last_line_position)
                
                if recovery.recovery_mode:
                    # Use recovery system
                    left_speed, right_speed = recovery.get_recovery_speeds()
                    
                    if recovery.should_stop_recovery():
                        # Recovery failed, do aggressive search
                        left_speed = SEARCH_SPEED
                        right_speed = -SEARCH_SPEED
                        recovery.reset()
                        print("Recovery timeout - aggressive search mode")
                else:
                    # Simple continuation in last direction
                    if last_line_position > 0.1:  # Line was on the right
                        left_speed = SEARCH_SPEED * 0.8
                        right_speed = SEARCH_SPEED * 0.3
                    elif last_line_position < -0.1:  # Line was on the left
                        left_speed = SEARCH_SPEED * 0.3
                        right_speed = SEARCH_SPEED * 0.8
                    else:  # Go straight briefly
                        left_speed = SEARCH_SPEED * 0.6
                        right_speed = SEARCH_SPEED * 0.6
                
                print(f"Search mode: Left: {left_speed:.2f}, Right: {right_speed:.2f}")
            
            # Update current speeds and apply
            current_left_speed = left_speed
            current_right_speed = right_speed
            set_motor_speeds(left_speed, right_speed)
            
            time.sleep(0.01)

    except KeyboardInterrupt:
        print("Interrupted by user")
    finally:
        print("Stopping simulation...")
        sim.stopSimulation()
