import os
import json
import time
import random
import numpy as np
from coppeliasim_zmqremoteapi_client import RemoteAPIClient

# =========================================================
# -------- CONFIG QUE *TÚ* PUEDES / DEBES TOCAR ----------
# =========================================================

WHEEL_D = 0.05          # m (diámetro de la llanta)
MAX_SPEED = 1.2         # m/s máx permitida para las ruedas
MAX_CORRECTION = 0.6    # qué tan fuerte puede girar (sube = gira más agresivo)

# Tus sensores están montados al lado izquierdo del robot.
# Para corregir la interpretación izquierda/derecha, estamos usando pesos
# invertidos con respecto al orden de índices de los sensores.
WEIGHTS = np.array([3, 2, 1, 0.5, -0.5, -1, -2, -3], dtype=float)

# MEDIDO POR TI:
# Cuando el robot está colocado como debe ir sobre la línea ("bien"),
# el weighted_pos estaba cerca de -5.
# Eso se vuelve nuestro punto objetivo.
TARGET_OFFSET = -5.0

# Si el robot todavía quiere girar hacia el lado opuesto,
# cambia esto de 1.0 a -1.0 y vuelve a probar.
STEERING_SIGN = 1.0

EPISODE_TIME = 4.0      # duración de cada episodio de prueba (s)
CONTROL_DT = 0.02       # tiempo entre pasos de control (s)
LOST_LINE_THRESHOLD = 0 # si s.sum() <= esto => asumimos línea perdida

LOG_DIR = "logs"
os.makedirs(LOG_DIR, exist_ok=True)


# =========================================================
# --------- CONEXIÓN A COPPELIASIM Y HANDLES --------------
# =========================================================

client = RemoteAPIClient('localhost', 23000)
sim = client.getObject('sim')

left_mtr = sim.getObject('/LineTracer/DynamicLeftJoint')
right_mtr = sim.getObject('/LineTracer/DynamicRightJoint')
cam_handles = [sim.getObject(f"/LineTracer/lineSensor[{i}]") for i in range(8)]


# =========================================================
# ---------------- FUNCIONES DEL ROBOT --------------------
# =========================================================

def get_sensor_values(threshold=0.2):
    """
    Devuelve lista de 8 valores 0/1 (1 = línea negra detectada).
    """
    states = []
    for h in cam_handles:
        img, res = sim.getVisionSensorImg(h)
        w, hres = int(res[0]), int(res[1])

        buf = np.frombuffer(img, dtype=np.uint8)
        frame = buf.reshape(hres, w, 3).astype(np.float32) / 255.0
        gray = frame.mean(axis=2)

        detected = 1 if gray.mean() < threshold else 0
        states.append(detected)
    return states


def set_motor_speeds(norm_left, norm_right):
    """
    norm_left / norm_right en [-1,1]
    -> velocidad lineal -> velocidad angular -> enviar al sim.
    """
    nl = max(-1.0, min(1.0, norm_left))
    nr = max(-1.0, min(1.0, norm_right))

    left_linear_velocity = nl * MAX_SPEED
    right_linear_velocity = nr * MAX_SPEED

    left_ang_vel = left_linear_velocity / (WHEEL_D / 2)
    right_ang_vel = right_linear_velocity / (WHEEL_D / 2)

    client.setStepping(True)
    sim.setJointTargetVelocity(left_mtr, left_ang_vel)
    sim.setJointTargetVelocity(right_mtr, right_ang_vel)
    client.setStepping(False)

    return nl, nr  # regresamos lo que mandamos, para métricas


def compute_line_error(sensors, last_error):
    """
    Convierte sensores binarios en 'error' que va al PID.
    1) Calcula weighted_pos con WEIGHTS.
    2) Le resta TARGET_OFFSET (tu posición ideal = -5).
    Así, si estamos "bien", error ~ 0 en lugar de error gigante.
    """
    s = np.array(sensors, dtype=float)
    active_sum = s.sum()

    if active_sum <= LOST_LINE_THRESHOLD:
        # línea perdida: continúa con el último error (gira hacia donde venía)
        return last_error

    weighted_pos = (WEIGHTS * s).sum() / active_sum

    # Ajuste crítico: TARGET_OFFSET = -5.0 (medido por ti)
    error = weighted_pos - TARGET_OFFSET
    return error


class PIDController:
    """
    Control PID clásico:
    salida = Kp*e + Ki*∫e dt + Kd*de/dt
    """
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.integral = 0.0
        self.prev_error = 0.0
        self.prev_time = None

    def reset(self):
        self.integral = 0.0
        self.prev_error = 0.0
        self.prev_time = None

    def update(self, error):
        now = time.time()

        if self.prev_time is None:
            dt = 0.0
        else:
            dt = now - self.prev_time
            if dt <= 0:
                dt = 1e-6

        P = self.Kp * error
        self.integral += error * dt
        I = self.Ki * self.integral
        d_error = (error - self.prev_error) / dt if dt > 0 else 0.0
        D = self.Kd * d_error

        self.prev_error = error
        self.prev_time = now

        return P + I + D


def apply_controller(pid_output, base_speed):
    """
    Convierte salida PID -> velocidades de rueda.
    STEERING_SIGN permite invertir el giro si está al revés.
    """
    correction = STEERING_SIGN * pid_output

    # límite de giro para que no se vuelva loco
    correction = max(-MAX_CORRECTION, min(MAX_CORRECTION, correction))

    left_cmd = base_speed - correction
    right_cmd = base_speed + correction

    # saturamos por seguridad
    left_cmd = max(-1.0, min(1.0, left_cmd))
    right_cmd = max(-1.0, min(1.0, right_cmd))

    return set_motor_speeds(left_cmd, right_cmd)


# =========================================================
# ----------- EPISODIO DE ENTRENAMIENTO -------------------
# =========================================================

def run_episode(params, episode_idx):
    """
    Corre un episodio con:
      {
        "Kp": float,
        "Ki": float,
        "Kd": float,
        "BASE_SPEED": float
      }

    Calcula recompensa y la guarda.
    """
    pid = PIDController(params["Kp"], params["Ki"], params["Kd"])
    pid.reset()

    base_speed = params["BASE_SPEED"]

    # Reinicia simulación al estado inicial
    sim.stopSimulation()
    time.sleep(0.2)
    sim.startSimulation()

    start_time = time.time()
    last_error = 0.0

    abs_error_sum = 0.0
    forward_sum = 0.0
    step_count = 0

    while sim.getSimulationState() != sim.simulation_stopped:
        now = time.time()
        if (now - start_time) >= EPISODE_TIME:
            break

        sensors = get_sensor_values()
        err = compute_line_error(sensors, last_error)
        last_error = err

        pid_out = pid.update(err)

        left_cmd, right_cmd = apply_controller(pid_out, base_speed)

        # Qué tan lejos de la línea estuviste:
        abs_error_sum += abs(err)

        # Qué tanto avanzaste hacia adelante:
        forward_cmd = (left_cmd + right_cmd) / 2.0
        if forward_cmd < 0:
            forward_cmd = 0.0
        forward_sum += forward_cmd

        step_count += 1
        time.sleep(CONTROL_DT)

    # parar robot y simulación
    set_motor_speeds(0.0, 0.0)
    sim.stopSimulation()
    time.sleep(0.1)

    if step_count == 0:
        avg_err = 999.0
        avg_forward = 0.0
    else:
        avg_err = abs_error_sum / step_count
        avg_forward = forward_sum / step_count

    # Recompensa:
    # queremos avanzar (avg_forward grande)
    # y queremos estar pegados donde toca (avg_err chico)
    reward = (2.0 * avg_forward) - (1.0 * avg_err)

    data = {
        "episode": episode_idx,
        "params": params,
        "avg_error": avg_err,
        "avg_forward": avg_forward,
        "reward": reward,
        "timestamp": time.time()
    }

    log_path = os.path.join(LOG_DIR, f"prueba_{episode_idx}.json")
    with open(log_path, "w") as f:
        json.dump(data, f, indent=2)

    print(f"[EP {episode_idx}] reward={reward:.3f}  err={avg_err:.3f}  fwd={avg_forward:.3f}")
    print(f"Guardado en {log_path}")

    return reward, data


# =========================================================
# ----------- BÚSQUEDA ESTILO RL / EVOLUTIVA --------------
# =========================================================

def mutate_params(best_params, scale=0.3):
    """
    Hace mutaciones gaussianas a los mejores parámetros actuales.
    """
    def mutate_positive(val, allow_zero=True):
        new_val = val + random.gauss(0, scale * (abs(val) + 1e-6))
        if allow_zero:
            new_val = max(0.0, new_val)
        else:
            new_val = max(0.05, new_val)  # evita velocidad base = 0
        return new_val

    new_params = {
        "Kp": mutate_positive(best_params["Kp"]),
        "Ki": mutate_positive(best_params["Ki"]),
        "Kd": mutate_positive(best_params["Kd"]),
        "BASE_SPEED": mutate_positive(best_params["BASE_SPEED"], allow_zero=False),
    }

    # limitar BASE_SPEED a [0,1] porque nuestro normalizado espera eso
    new_params["BASE_SPEED"] = min(1.0, new_params["BASE_SPEED"])

    return new_params


def save_best(best_data):
    best_path = os.path.join(LOG_DIR, "best_params.json")
    with open(best_path, "w") as f:
        json.dump(best_data, f, indent=2)
    print(f"[MEJOR ACTUALIZADO] {best_path}")


if __name__ == "__main__":
    # Semilla inicial (puedes bajarle BASE_SPEED si todavía patina o gira feo)
    best_params = {
        "Kp": 0.6,
        "Ki": 0.0,
        "Kd": 0.1,
        "BASE_SPEED": 0.4
    }

    best_reward, best_data = run_episode(best_params, episode_idx=0)
    save_best(best_data)

    NUM_EPISODES = 10

    for ep in range(1, NUM_EPISODES + 1):
        cand_params = mutate_params(best_params, scale=0.3)

        reward, data = run_episode(cand_params, episode_idx=ep)

        # Si mejora la recompensa, adoptamos esos parámetros
        if reward > best_reward:
            best_reward = reward
            best_params = cand_params
            best_data = data
            save_best(best_data)

    # apagar motores al final por seguridad
    set_motor_speeds(0.0, 0.0)
